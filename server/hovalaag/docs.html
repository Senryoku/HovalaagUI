<html>
<head>
<title>HOVALAAG Processor Documentation</title>
<style>
pre { font-size: 150%; text-align: left; display:inline-block;}
a:link { color: #ffcc60; }
a:visited { color: #cc9c00; }
img { vertical-align:top; }
</style>
</head>
<body style="text-align: center; background-color: #000000; color: #eebb00;">
<pre>
HOVALAAG Processor Documentation

The processor in HOVALAAG is the &#9608;&#9608;&#9608;&#9608;&#9608; designed by &#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608; &#9608;&#9608&#9608;&#9608;&#9608; Technologies in 19&#9608;&#9608;.
It is a Harvard architecture VLIW processor with no data storage, only instruction
storage. The original CPU could only address 64 instruction words; HOVALAAG uses the
later &#9608;&#9608; variant which allows 256 program words (although only the first 64 can be
branched to with "short" labels).

Each instruction is encoded in 32 bits as follows:

<table cellpadding=2 cellspacing=0 border=1>
<tr>
<td width="3.125%">31</td><td width="3.125%">30</td><td width="3.125%">29</td><td width="3.125%">28</td>
<td width="3.125%">27</td><td width="3.125%">26</td><td width="3.125%">25</td><td width="3.125%">24</td>
<td width="3.125%">23</td><td width="3.125%">22</td><td width="3.125%">21</td><td width="3.125%">20</td>
<td width="3.125%">19</td><td width="3.125%">18</td><td width="3.125%">17</td><td width="3.125%">16</td>
<td width="3.125%">15</td><td width="3.125%">14</td><td width="3.125%">13</td><td width="3.125%">12</td>
<td width="3.125%">11</td><td width="3.125%">10</td><td width="3.125%"> 9</td><td width="3.125%"> 8</td>
<td width="3.125%"> 7</td><td width="3.125%"> 6</td><td width="3.125%"> 5</td><td width="3.125%"> 4</td>
<td width="3.125%"> 3</td><td width="3.125%"> 2</td><td width="3.125%"> 1</td><td width="3.125%"> 0</td>
</tr>
<tr>
<td colspan=4 align=center><a href="#alu">ALU</a></td>
<td colspan=2 align=center><a href="#a">A</a></td>
<td colspan=2 align=center><a href="#b">B</a></td>
<td colspan=2 align=center><a href="#c">C</a></td>
<td colspan=1 align=center><a href="#d">D</a></td>
<td colspan=2 align=center><a href="#w">W</a></td>
<td colspan=2 align=center><a href="#f">F</a></td>
<td colspan=2 align=center><a href="#pc">PC</a></td>
<td colspan=1 align=center><a href="#o">O</a></td>
<td colspan=1 align=center><a href="#io">IO</a></td>
<td colspan=1 align=center><a href="#x">X</a></td>
<td colspan=6 align=center><a href="#k">K</a></td>
<td colspan=6 align=center><a href="#l">L</a></td>
</tr></table>

See "sample.vasm" for documentation on assembly language syntax.

In all cases, the values used are the values in the registers at
the start of the instruction. In other words, all operations
proceed in parallel (except as noted).

<hr>
<a name="alu">ALU</a>

The Arithmetic &amp; Logic Unit can perform one of sixteen possible computations.

<table>
<tr><td>0000 &nbsp;</td> <td>0</td> <td>constant zero (<i>not</i> the value of K)</td></tr>
<tr><td>0001</td><td>-A</td><td>negated value of A register</td></tr>
<tr><td>0010</td><td>B</td><td>value of B register</td></tr>
<tr><td>0011</td><td>C</td><td>value of C register</td></tr>
<tr><td>0100</td><td>A>>1</td><td>signed right bitshift of A; see notes below</td></tr>
<tr><td>0101</td><td>A+B</td><td>sum of A and B registers</td></tr>
<tr><td>0110</td><td>B-A</td><td>difference of B and A registers</td></tr>
<tr><td>0111</td><td>A+B+F</td><td>sum of A and B, and carry from 1-bit F register</td></tr>
<tr><td>1000</td><td>B-A-F</td><td>difference of B and A, and borrow from 1-bit F register</td></tr>
<tr><td>1001</td><td>A|B</td><td>bitwise OR of A and B</td></tr>
<tr><td>1010</td><td>A&B</td><td>bitwise AND of A and B</td></tr>
<tr><td>1011</td><td>A^B</td><td>bitwise XOR of A and B</td></tr>
<tr><td>1100</td><td>~A</td><td>bitwise inverse of A</td></tr>
<tr><td><s>1101</s></td><td><s>BCD A+B</s></td><td><s>binary-coded duodecimal add</s></td></tr>
<tr><td><s>1110</s></td><td><s>BCD B-A</s></td><td><s>binary-coded duodecimal subtract</s></td></tr>
<tr><td><s>1111</s></td><td><s>BCD A+B+F</s>&nbsp;</td><td><s>binary-coded duodecimal add with carry</s></td></tr>
</table>

Note 1: A>>1 (1000b) causes the F operation to use the bottom bit of A instead
of the hidden top bit of the ALU operation when computing the new value of F.
This means you can load the bottom bit of A into F using NEG(A>>1).

Note 2: the BCD instructions, which compute base-12 arithmetic,
are not supported by the HOVALAAG assembler or the HOVALAAG emulator.

Note 3: registers that <i>load</i> from the ALU (later in this
document) load the value computed by the ALU in this cycle, not
the previous cycle (the ALU is not a register).

<hr>
<a name="a">A</a>

A is a 12-bit generic register used as an input to the ALU and used
for loading data from input.

<table>
<tr><td>00 &nbsp;</td> <td>&nbsp;</td>        <td>A is unchanged</td></tr>
<tr><td>01</td>        <td>A=ALU</td>         <td>A is loaded from the ALU computation</td></tr>
<tr><td>10</td>        <td>A=D</td>           <td>A is loaded from register D</td></tr>
<tr><td>11</td>        <td>A=IN# &nbsp;</td>  <td>A is loaded from input stream 1 or 2, depending on the value of IO</td></tr>
</table>

<hr>
<a name="b">B</a>

B is a 12-bit generic register used as an input to the ALU. It also
allows feeding a constant embedded in the instruction to the ALU.

<table>
<tr><td>00</td>         <td>&nbsp;</td>        <td>B is unchanged</td></tr>
<tr><td>01</td>         <td>B=ALU &nbsp;</td>         <td>B is loaded from the ALU computation</td></tr>
<tr><td>10</td>         <td>B=A</td>           <td>B is loaded from register A</td></tr>
<tr><td>11 &nbsp;</td>  <td>B=K</td>           <td>B is loaded from the constant K in the instruction word</td></tr>
</table>
If the X bit is set, the 6-bit constant K is replaced by
the 12-bit constant K:L.

<hr>
<a name="c">C</a>

C is a 12-bit counting register used to allow efficient looping.

<table>
<tr><td>00</td>        <td>&nbsp;</td>          <td>C is unchanged</td></tr>
<tr><td>01</td>        <td>C=ALU &nbsp;</td>    <td>C is loaded from the ALU computation</td></tr>
<tr><td>10</td>        <td>DEC</td>             <td>compute C=C-1</td></tr>
<tr><td>11 &nbsp;</td> <td>DECNZ</td>           <td>compute C=C-1; if the result is non-zero, branch to address L</td></tr>
</table>
If the X bit is set, the 6-bit constant L is conceptually replaced by
the 12-bit constant K:L. In practice, only the bottom 8 bits of the
combined constant are loaded into the 8-bit program counter.

<hr>
<a name="d">D</a>

D is a 12-bit data storage register which can be easily swapped with register A.

<table>
<tr><td>0 &nbsp;</td> <td>&nbsp;</td>        <td>D is unchanged</td></tr>
<tr><td>1</td>        <td>D=A &nbsp;</td>    <td>D is loaded from A</td></tr>
</table>

<hr>
<a name="w">W</a>

W is a 12-bit buffer register used to store values meant to be written to an
output stream. It is not possible to get values stored in W back into the rest
of the CPU.

<table>
<tr><td>00 &nbsp;</td> <td>&nbsp;</td>        <td>W is unchanged</td></tr>
<tr><td>01</td>        <td>W=ALU &nbsp;</td>  <td>W is loaded from the ALU computation</td></tr>
<tr><td>10</td>        <td>W=A</td>           <td>W is loaded from register A</td></tr>
<tr><td>11</td>        <td>W=K</td>           <td>W is loaded from constant K in the instruction word</td></tr>
</table>
If the X bit is set, the 6-bit constant K is replaced by
the 12-bit constant K:L.

<hr>
<a name="f">F</a>

F is a 1-bit register which is used for conditional branches and as a carry flag.

<table>
<tr><td>00 &nbsp;</td> <td>&nbsp;</td>             <td>F is unchanged</td></tr>
<tr><td>01</td>        <td>F=ZERO(ALU) &nbsp;</td> <td>F is 1 iff the ALU computation is zero</td></tr>
<tr><td>10</td>        <td>F=NEG(ALU)</td>         <td>F is 1 iff the ALU computation is negative</td></tr>
<tr><td>11</td>        <td>F=POS(ALU)</td>         <td>F is 1 iff the ALU computation is positive</td></tr>
</table>
Note that the ALU computation is computed with a hidden sign bit, so
F=NEG(B-A) will be 1 if A > B, even if the computation overflows.

Note that if the ALU computation is A>>1, the original bottom bit of A
is used as the hidden sign bit, so F=NEG(A>>1) loads the bottom bit of A into F.

<hr>
<a name="pc">PC</a>

The 8-bit PC register stores the program counter, which is the index of the
instruction word currently being executed by the processor. The unit is used
to implement conditional and unconditional branches. The value of the program
counter cannot be loaded to or from other registers in the processor.

<table>
<tr><td>00 &nbsp;</td> <td>&nbsp;</td>       <td>execution proceeds to the next instruction</td></tr>
<tr><td>01</td>        <td>JMP &nbsp;</td>   <td>unconditional branch to instruction L</td></tr>
<tr><td>10</td>        <td>JMPT</td>         <td>branch to instruction L if F is 1</td></tr>
<tr><td>11</td>        <td>JMPF</td>         <td>branch to instruction L if F is 0</td></tr>
</table>
Note that DECNZ in the C unit can also trigger a branch to L.

If the X bit is set, the 6-bit constant L is conceptually replaced by
the 12-bit constant K:L. In practice, only the bottom 8 bits of the
combined constant are loaded into the 8-bit program counter.

<hr>
<a name="o">O</a>

O is the name of the "output" unit, which allows writing to an output stream.

<table>
<tr><td>0 &nbsp;</td> <td>&nbsp;</td>         <td>no output</td></tr>
<tr><td>1</td>        <td>OUT#=W &nbsp;</td>  <td>output the value in W to output stream #IO</td></tr>
</table>

<hr>
<a name="io">IO</a>

A 1-bit selector that determines which input and output stream should
be accessed this cycle. It has no effect if no input or output is
performed. Because there is only a single bit, it is not possible to
read from IN0 and write to OUT1 in the same cycle; similarly IN1 and OUT0.

<table>
<tr><td>0 &nbsp;</td> <td>IN1,OUT1</td>         <td>use input and/or output stream 1</td></tr>
<tr><td>1</td>        <td>IN2,OUT2 &nbsp;</td>  <td>use input and/or output stream 2</td></tr>
</table>

<hr>
<a name="x">X</a>

A flag which indicates that the two 6-bit constants below should
be combined into a single 12-bit constant.

<hr>
<a name="k">K</a>

A 6-bit constant in the instruction word used for arithmetic.
Sign-extended to 12 bits. Can be full 12-bit constant by setting the X flag.

<hr>
<a name="l">L</a>

A 6-bit constant in the instruction word used for branch targets.
Zero-extended to 8 bits. Can be full 8-bit constant by setting the X flag.

</html>
